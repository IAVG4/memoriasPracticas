<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Metainformación sobre el documento-->
      <meta charset="utf-8">
      <meta name="author" content="Grupo 10 - IU" /> 
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
      <!-- Etiquetas para el navegador-->
      <meta name="keywords" content="IA, AI, IAV, practicas, Unity, algoritmos, informática, web" />
      <meta name="description" content="Memorias Practicas IAV" />

        <!-- Links -->
      <link rel="icon" href="./images/logoUCM.png">
        <!-- Bootstrap core CSS -->
      <link href="../dist/css/bootstrap.min.css" rel="stylesheet">
          <!-- Bootstrap theme -->
      <link href="../dist/css/bootstrap-theme.min.css" rel="stylesheet">

      <link href="../css/estilosPropios.css" rel="stylesheet">


  </head>

  <body>

    <div class="container-fluid">
    <div class="row">

        <div class="col-xs-3 col-sm-2 col-md-2 sidebar">
            <a href="../index.html"><img src = "../images/logoUCM.png" class= "img-responsive" alt= "Imagen responsive"></a>

            <ul class="nav nav-sidebar">

            <li><a href="../index.html"><b>Inicio</b></a></li>
            <li><a href="../index/Practica1.html"><b>Práctica 1</b></a></li>
            <li class="active"><a href="./index/Practica2.html">Práctica 2 <span class="sr-only">(current)</span></a></li>
            <!--<li><a href="./Practica3.html"><b>Práctica 3</b></a></li>
            <li><a href="./Practica4.html"><b>Práctica 4</b></a></li>
            <li><a href="./Practica5.html"><b>Práctica 5</b></a></li>
            <li><a href="./Practica6.html"><b>Práctica 6</b></a></li>-->

          </ul>
        </div>



      <div class="col-xs-offset-1 col-xs-10 col-sm-8 col-sm-offset-3 col-md-8 col-md-offset-3 main">
      <div class="container-fluid">

      <div class="row">

          <div class="jumbotron">

              <h1 class="text-center">Práctica 2</h1>
              <br>

                <h2><b>Resumen</b></h2>
                <br>
                 
                  <p>
                    En la práctica dos presentamos un tablero de compuesto por cien <b>casillas</b> (normal, embarrada, bloqueada) en una matriz de 10x10. En este tablero se colocan aleatoriamente tres unidades, tres <b>fichas</b>, que serán el sitio donde comenzarán a moverse para llegar al destino definido por el jugador. Este destino se define haciendo clic en una casilla no bloqueada después de seleccionar la ficha que quiere mover.
                  </p>
                
                <hr>
                <br>

                <h2><b>Problema a resolver</b></h2>
                <br>

                  <p>
                  	El problema a resolver es encontrar el camino más óptimo para que cada ficha llegue a su destino. A nivel de programación el problema es utilizar un algoritmo que encuentre el camino con menor coste entre un nodo origen y otro destino. Este algoritmo que buscamos es el A* o Astar.

                  </p>
                  <br>
                  <div class="text-center">
                       <div class="col-10 col-md-100"><img src = "../images/AStarPart.jpg" class= "img-responsive" alt= "Imagen responsive" width = "250" height = "250"></a></div>
                  </div>
                  <br>
                  

                    <hr>
                    <br>

                      
                    <h2><b>Método de resolución</b></h2>
                    <br>
                    <h3><b>A*</b></h3>
                    <p>
                    	Nuestro A * o algoritmo de búsqueda resuelve problemas buscando entre todas las rutas posibles y de entre estos caminos primero considera los que parecen conducir más rápidamente a la solución. A partir de un nodo específico de una matriz de nodos construye un árbol de rutas, expandiendo las rutas un paso a la vez, hasta que una de sus rutas termina encontrando el nodo objetivo.
                    </p>

                    <p>
                    En cada iteración de su bucle principal, el algoritmo determina cuál de sus rutas se expandirá. Esto lo hace con la selección del nodo con la menor estimación del coste, calculada con la función:
                    </p>

                    <p>
                    f (n) = g (n) + h (n)
                    </p>

                    <p>
                    Donde n es el nodo del que se está calculando el coste, g (n) es el coste de la ruta desde el nodo de inicio a n, y h (n) es una heurística que estima el coste de la ruta más barata desde n hasta el objetivo. 
                    </p>

                    <p>
                    Usamos una cola de prioridad (open) para almacenar los nodos con los que se está trabajando y realizar la selección de nodos de coste mínimo. En cada paso del algoritmo, el nodo con el valor f (x) más bajo se elimina de la cola, sus vecinos que no estén en la cola se añaden y a los que ya estén les actualiza sus valores f y g. El algoritmo continúa hasta que un nodo al añadir un vecino encuentre la posición final o hasta que se vacíe la cola (lo que indicaría que no existe solución).
                    </p>

                    <p>
                    Para encontrar la secuencia real de pasos, cada nodo almacena su predecesor. Esto permite que después de ejecutar el algoritmo, el nodo final apuntará a su predecesor, y así sucesivamente, hasta que el predecesor de algún nodo sea el nodo de inicio.
                    </p>
                    
                    <br>
                   
                    <hr>
                <br> 
                    <h2><b>Herramientas utilizadas</b></a></h2>
                    <br>

                     <h4><li type="disc"><b>Unity:</b> motor de la aplicación</li></h4>
                     <h4><li type="disc"><b>Monodevelop:</b> Entorno de desarrollo</li></h4>
                     <h4><li type="disc"><b>C#:</b> lenguaje de programación</li></h4>
                     <h4><li type="disc"><b>Cola de prioridad externa.</b></li></h4>

                     <hr>
                <br> 
                    <h2><b>Implementación</b></a></h2>
                    <br>

                    <ul>
                      <h4> 
                        <li><b>Ficha:</b> componente de cada ficha de la matriz 
                          <ul> 
                            <li><b>Vector2 positionInMatrix:</b> posición lógica de la ficha dentro de la matriz.</li>
                            <li><b>OnMouseDown():</b>  comprueba el clic en la ficha y llama a <b>SetFichaSeleccionada()</b>, una función del GameManager.</li>
                            <li><b>SetPositionInMatrix():</b> setter de positionInMatrix.</li>
                            <li><b>GetPositionInMatrix():</b> getter de positionInMatrix.</li> 
                          </ul> 
                        </li>
                        <br>
                        <li><b>Casilla:</b> componente de cada casilla de la matriz 
                          <ul> 
                            <li><b>Vector2 positionInMatrix:</b> posición lógica de la ficha dentro de la matriz.</li>
                            <li><b>OnMouseDown():</b>  comprueba el clic en la casilla y llama a <b>OnClick()</b>, una función del GameManager.</li>
                          </ul> 
                        </li>
                        <br>
                        <li>
                          <b>GameManager:</b> gestiona y realiza los movimientos de la matriz y lee el input de teclado:
                          <ul>
                            <li>
                              <b>Atributos:</b>
                              <ul>
                                <li><b>public enum tipoCasilla:</b> Controla lo que hay en un cuadrado del tablero. Si hay solo una casilla, el tipo de esta, si no, indica que hay una ficha.</li>
                                <li><b>tipoCasilla [,] tablero:</b> Matriz con los tipos de casillas.</li>
                                <li><b>Atributos que necesita la IA:</b>
                                  <ul>
                                    <li><b>int [,] tablero01:</b> Matriz de enteros, solo 0 y 1, que simbolizan casillas disponibles y no disponibles para pasar, respectivamente.</li>
                                    <li><b>Vector2 posicionInicial:</b> Coordenadas de la ficha que vamos a mover.</li>
                                    <li><b>Vector2 posicionFinal:</b> Coordenadas del destino de la ficha que queremos mover.</li>
                                  </ul>
                                </li>
                                <li><b>public GameObject Casilla: </b> Prefab de cualquier casilla del tablero</li>
                                <li><b>public Sprite *******</b> Son los sprites que representan el tipo de casilla (normal, embarrada, bloqueada).</li>
                                <li><b>public GameObject *******</b> Los gameObjects de las tres fichas y de las tres cruces.</li>
                                <li><b>GameObject *******</b> Estos gameObjects son los que controlan la ficha que queremos mover y a donde.</li>
                              </ul>
                            </li>
                            <li><b>Start():</b> Llama a <b>CreaFichas()</b> y a <b>CreaTablero()</b></li>
                            <li><b>Update():</b> De momento solo debug.</li>
                            <li><b>SetFichaSeleccionada():</b> Se encarga de cambiar la ficha seleccionada, tanto a nivel lógico como a nivel visual.</li>
                            <li><b>OnClick():</b> Cambia las casillas de tipo y señala la casilla destino en caso de que el anterior click hubiera sido una ficha.</li>
                            <li><b>Creafichas():</b> Coloca las fichas en un sitio aleatorio del tablero</li>
                            <li><b>CreaTablero():</b> Rellena tablero de casillas colocando un numero de casillas embarradas y bloqueadas delimitado. Estas casillas tienen una posición aleatoria.</li>
                          </ul>
                        </li>
                        <br>
                        <li>
                          <b>Astar1:</b> Componente poseedor del algoritmo de búsqueda.
                          <ul>
                            <li><b>Node[,]tableroNode:</b> Guarda la matriz de nodos.</li>
                            <li><b>bool [,] marked:</b>Marca las casillas que ya no se tienen que comprobar.</li>
                            <li><b>FastPriorityQueue &lt;Node&gt; open: </b> Almacena los nodos abiertos (que se están procesnado).</li>
                            <li><b>int[,] tablero: </b> Recibe y guarda los tipos de casilla.</li>
                            <li>
                              <b>Class Node:</b> Nodo del tablero.
                              <ul>
                                <li><b>Enum state:</b> marcan el estado de del nodo.</li>
                                <li><b>public Vector2 pos:</b>coordenadas del nodo.</li>
                                <li><b>Int h:</b> distancia desde el nodo hasta el nodo objetivo.</li>
                                <li><b>Int cost:</b>el coste que tiene pasar por ella.</li>
                                <li><b>Int g:</b>coste para llegas a ese nodo.</li>
                                <li><b>Int f:</b>h + g.</li>
                                <li><b>public Node Padre:</b> Representa el nodo padre al actual.</li>
                                <li><b>public Node():</b> Constructora donde se inicializan los atributos anteriores</li>
                              </ul>
                            </li>
                            <li><b>List &lt;Vector2&gt; calculatePath()</b> heurística que calcula el coste de la ruta más barata desde un nodo hasta otro.</li>
                            <li><b>int ManhattanDistance():</b> heurística que calcula el coste de la ruta más barata desde un nodo hasta otro.</li>
                            <li><b>Node addNeighbours():</b> añade vecinos a open y devuelve el nodo solución si lo encuentra.</li>
                            <li><b>fillMarked():</b> Rellena la matriz marked.</li>
                            <li><b>void fillTableroNode():</b>rellena la matriz tableroNode.</li>
                            <li><b>List<Vector2> getPath():</b>devuelve la lista de posiciones del recorrido a partir del nodo final.</li>
                          </ul>
                        </li>
                      </h4>
                    </ul>
                    <hr>
                  <br>
                     <h2><b>Resultados obtenidos</b></h2>
                     <br>
                    <ul>
                      <h3><li type="disc"><b>Objetivos completados</b></li></h3>
                      <p>
                        Todo lo relacionado con Unity en la práctica que se utiliza antes de llamar al algoritmo funciona de una manera correcta y eficiente. La implementación de A* utilizada funciona de una manera eficaz.
                      </p>
                      <br>
                      <h3><li type="disc"><b>Objetivos incompletados</b></li></h3>
                      <p>
                        Cuando la ficha llega a su objetivo, si se vuelve a clicar, aparece en la posición en la que se instanció en el tablero. Creemos que es por un problema de copiar el transform de los gameObjects, pero no hemos conseguido corregirlo por el momento.
                      </p>
                      <br>
                      <h3><li type="disc"><b>Dificultades</b></li></h3>
                      <p>
                        La mayor parte de las dificultades las hemos encontrado en el GameManager. A la hora de controlar el click en los gameObjects 2D, los colliders de los objetos están a la misma altura, se solapan. La solución ha sido desactivar el componente BoxCollider2D en las casillas donde estén las fichas. Cuando se mueva la ficha esa casilla volverá a tener el componente activo.  
                      </p>
                      <p>
                        Otro inconveniente fue el control de la ficha seleccionada y de seleccionar posteriormente la casilla destino, donde aparecería una cruz del color de la ficha. Además, hemos llegado a implementar tres versiones de A* para llegar a la óptima para nuestra práctica.
                      </p>

                    </ul>

                    <hr>
                <br>
                    <h2><b>Relación bibliográfica</b></h2>
                    <br>

                    <p><a href="https://es.wikipedia.org/wiki/Algoritmo_de_b%C3%BAsqueda_A*/" target="_blank" >
                     https://es.wikipedia.org/wiki/Algoritmo_de_b%C3%BAsqueda_A* 
                    </a></p>
                    <p><a href="http://www.stackoverflow.com/" target="_blank" >
                    www.stackoverflow.com
                    </p>
                    <p><a href="http://www.unity3d.com/" target="_blank" >
                    www.unity3d.com
                    </p>
                    <p><a href="http://www.forum.unity.com/" target="_blank" >
                    www.forum.unity.com 
                    </p>
                    <p><a href="http://www.microsoft.com/" target="_blank" >
                    www.microsoft.com 
                    </p>
                    <p><a href="http://buildnewgames.com/astar/" target="_blank" >
                    http://buildnewgames.com/astar
                    </p>
                    <p><a href="http://www.youtube.com/channel/UCJdQxmnPls4rIwxCHS1szTQ/" target="_blank" >
                    www.youtube.com/channel/UCJdQxmnPls4rIwxCHS1szTQ
                    </p>
                    <p><a href="https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/" target="_blank" >
                    https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp
                    </p>
            </div>

          </div>
      </div>
      </div>
      </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="../../dist/js/bootstrap.min.js"></script>
    <!-- Just to make our placeholder images work. Don't actually copy the next line! -->
    <script src="../../assets/js/vendor/holder.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
